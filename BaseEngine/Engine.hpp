#pragma once
#include <map>
#include "Dice.hpp"
#include "Tile.hpp"
#include "PlayerContainer.hpp"

//TODO: Obs³uga Ctr-C itp. (zabezpieczenie przed niekontrolowanym zamkniêciem)
//TODO: (WIN) Brak blokowania konsoli po klikniêciu

/**
* Klasa enum dla stanów silnika.
*/
enum class EngineStates
{
	CREATED = 0,
	STARTED = 1,
	DICE_ROLLED = 2,
	MOVE_MADE = 3,
	STEP_MADE = 4
};

/** Klasa silnika gry w wersji offline.
* @author Jakub Jach &copy; 2022
*/
class Engine
{

protected:
	/**
	Nr aktualnego gracza od 0 do liczby graczy.
	*/
	int currentPlayer;
	/** Obecny stan silnika */
	EngineStates state;
	/** Zbiór, który przechowuje graczy w postaci <æwiartka, gracz> */
	std::map<int, PlayerContainer*> players;
	/** Tablica wyników */
	std::vector<Player*> top;
	/**
	Podstawowa plansza do Chiñczyka.
	*/
	std::array<Tile, 52> tiles;
	/**
	Kostka do gry.
	*/
	Dice dice;
	/** Zwraca dystans jaki pokona gracz jeœli chce przesun¹æ pionek na wybrane pole.
	* @param c - Kontener z danymi gracza.
	* @param dest - Docelowy kafelek na planszy.
	* @return Odleg³oœæ od punktu pocz¹tkowego gracza.
	*/
	unsigned int getDistance(PlayerContainer& c, unsigned int dest);
	/**
	* Zwraca aktualny obiekt PlayerContainer.
	* @return Obecny PlayerContainer.
	*/
	PlayerContainer& getCurrentPlayerContainer() { return *std::next(players.begin(), currentPlayer)->second; }
	/**
	* Przesuwa gracza na planszy.
	* @param fieldNo Numer pola na planszy.
	* @return true przy powodzeniu lub false w przeciwnym wypadku.
	*/
	bool moveCounterOnBoard(unsigned int fieldNo);
	/**
	* Przesuwa gracza na ostatnich polach.
	* @param fieldNo Numer pola.
	* @return true przy powodzeniu lub false w przeciwnym wypadku.
	*/
	bool moveCounterOnLast(unsigned int fieldNo);
	/**
	* Dodaje pionek na koñcowe pola na pozycjê wskazan¹ przez offset.
	* @param from Numer pola na planszy.
	* @param offset O ile przesun¹æ pionek na koñcowych polach.
	* @return true przy powodzeniu lub false w przeciwnym wypadku.
	*/
	bool moveCounterToLast(unsigned int from, unsigned int offset);
	/**
	* Przenosi pionki z kafelka z powrotem do domków.
	* @param t Referencja do kafelka, z którego pobrane maj¹ zostaæ zbite pionki.
	* @return true przy powodzeniu lub false w przeciwnym wypadku.
	*/
	bool beatCountersToHolder(Tile& t);
	/**
	Kolejny krok w grze. Aktualizuje informacje o wykonaiu ruchu czy rzucie kostk¹ oraz zmienia aktywnego gracza.
	@return true przy powodzeniu lub false w przeciwnym wypadku.
	*/
	bool step();

public:
	/**
	Wersja silnika
	*/
	static const std::string _VERSION;
	/**
	Mapa stanów silnika na ci¹g znaków.
	*/
	static const std::map<EngineStates, std::string> stateStr;
	/**
	Mapa stanów silnika na wartoœæ liczbow¹.
	*/
	static const std::map<EngineStates, int> stateInt;
	/**
	Mapa wartoœci liczbowej na stan silnika.
	*/
	static const std::map<int, EngineStates> intState;

	/**
	* Domyœlny konstruktor klasy Engine
	*/
	Engine();
	/** Tworzy obiekt na bazie przekazanego obiektu JSON.
	* @param obj - Obiekt, na bazie którego ma byæ tworzony silnik.
	*/
	Engine(nlohmann::json&);

	/** Pozwala dodaæ gracza do wybranej æwiartki planszy.
	* @param player - Gracz, który ma zostaæ dodany UWAGA: przekazaæ new Player(), poniewa¿ gracze s¹ usuwani przy destrukcji obiektu (aby nie mo¿na ich by³o u¿yæ przy nowej grze).
	* @param quarter - Æwiartka, w której gracz mo¿e rozpocz¹æ grê od 1 do 4.
	*/
	virtual bool addPlayer(Player* player, unsigned int quarter);

	/** Pobiera aktualnego gracza.
	* @return WskaŸnik na gracza aktualnie posiadaj¹cego ruch lub nullptr jeœli pobranie go jest niemo¿liwe.
	*/
	Player* getCurrentPlayer() { if (currentPlayer < 0 || players.size() == 0)return nullptr; return std::next(players.begin(), currentPlayer)->second->getPlayerPtr(); }

	/** Inicjuje grê.
	* Powoduje to zablokowanie mo¿liwoœci dodawnia graczy i ustawia stan rozgrywki.
	* @return true jeœli mo¿liwe jest uruchomienie gry lub false w przeciwnym wypadku.
	*/
	virtual bool start();

	/** S³u¿y do rzucania kostk¹.
	* @return Liczba oczek wyrzucona na kostce.
	*/
	virtual unsigned int rollDice();

	/** S³u¿y do pobrania liczby oczek wyrzuconych w ostatnim rzucie.
	* @return Liczba oczek wyrzucona na kostce.
	*/
	unsigned int getDice() { return dice.getLast(); }

	/** S³u¿y do poruszania pionkiem gracza. Jako gracz poruszaj¹cy wybierany jest aktualny gracz.
	* @param fieldNo - Pole, z którego ma ruszyæ siê pionek. Dla wystawienia pionka gracza nale¿y u¿yæ wartoœci < 0. Aby ruszyæ pionek na ostatnich szeœciu polach nale¿y wybraæ wartoœci 101-105 201-205 301-305 401-405
	* @return true jeœli ruch siê powiedzie lub false w przeciwnym razie np. pionek nie stoi na danym polu.
	*/
	virtual bool move(int fieldNo);

	/** Informuje, czy wszyscy gracze zakoñczyli grê tj. czy wszystkie ich pionki dotar³y do ostatniego pola.
	* @return Czy nale¿y zakoñczyæ rozgrywkê.
	*/
	bool finished();

	/** Pobiera listê z polami planszy.
	* @return Lista z polami na planszy.
	*/
	std::array<Tile, 52>& getTiles() { return tiles; }
	/** Zwraca listê z liczb¹ pionków dla gracza z danej æwiartki.
	* @return Lista z liczb¹ pionków na ka¿dym z pól.
	*/
	std::array<unsigned int, 6> getLast(unsigned int quarter) { return players[quarter - 1]->getLastCount(); }

	/** Zwraca liczbê pionków w domku dla gracza z danej æwiartki.
	* @param quarter - Numer æwiartki, z której ma zostaæ pobrana iloœæ pionków w domku.
	* @return Liczba pionków w domku dla danejæwiartki.
	*/
	unsigned int getHolderCount(unsigned int quarter) { return players[quarter - 1]->holderCount(); }
	/**
	* Zwraca mapê z kluczem bêd¹cym æwiartk¹ planszy a wartoœci¹ id gracza.
	* @return Mapa okreœlaj¹ca powi¹zania æwiartki z graczem.
	*/
	std::map<unsigned int, unsigned int> getQuarters();

	/**
	* Zwraca referencjê do obiektu PlayerContainer.
	* @param quarter Æwiartka, z której ma zostaæ pobrany PlayerContainer.
	* @return Referencja na PlayerContainer z danej æwiartki lub wyj¹tek przy podaniu z³ej wartoœci æwiartki.
	*/
	PlayerContainer& getPlayerContainer(unsigned int quarter) { return *players[quarter - 1]; }

	/**
	* Zwraca aktualny stan silnika.
	* @return Klasa enum EngineStates aktualnego stanu.
	*/
	EngineStates getCurrentState() { return state; }
	/** Zwraca wektor z wynikami graczy */
	std::vector<Player*>& getTop() { return top; }

	/**
	* Umo¿liwia przekierowanie do strumienia.
	* Wyjœcie w postaci takiej jak metoda json() (bez jej wywo³ywania)
	* @param os Strumieñ wyjœciowy
	* @param e Obiekt silnika, który ma zostaæ wyœwietlony.
	* @return Strumieñ os.
	*/
	friend std::ostream& operator<< (std::ostream& os, const Engine& e);
	/**
	* Zwraca reprezentacjê obiektu w bardziej czytelnej postaci
	*/
	std::string str();
	/**
	* Zwraca obiekt w postaci tekstu JSON.
	*/
	std::string json();

	/** Domyœlny destruktor usuwa wszystkich graczy*/
	~Engine();
};


